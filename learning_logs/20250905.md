# 금일 복습 목록
- 목록
  1. collection
  2. classes

## collection
python 대표 collection 종류
1. list 리스트 : 추가 / 수정 / 삭제가 언제나 가능 / 순서 있음
   2. tuple 튜플 : 추가 / 수정 / 삭제가 불가능 / 순서 있음
   3. set 세트 : 중복된 값의 저장이 불가능 / 순서 없음
   4. dict 딕셔너리 : 키 + 값으로 관리

1. list
여러 값을 저장할 때 가장 많이 사용. 자료형이 서로 다르더라도 하나의 리스트에 저장 가능. 하나의 배열(파이썬에서 리스트와 비슷한 개념)에 동일한 자료형만을 저장할 수 있는 C, Java에 비해 python이 가지는 장점 중 하나(근데 JS는 또 다양한 자료형이 배열에 저장되긴 합니다).

- list의 index / slice
list는 str와 동일한 방식의 index / slicing을 지원

  1) 인덱스 / 마이너스 인덱스
  2) slicing
      str의 슬라이싱과 같이 '시작인덱스 : 종료인덱스 : 증감값'으로 이루어져 있음.
  3) list element의 추가와 삭제
          list에 새로운 요소를 추가할 때는 어제한 것 처럼 .append() / .insert() 'metho'를 사용할 수 있습니다.
          기존 요소를 삭제할 때는 .pop() 메서드를 사용합니다.
     - .append() - 항상 마지막 인덱스에 element를 추가
     - .insert() - 정해진 위치(인덱스)에 해당 값을 추가
     - .pop()의 경우 빈 괄호로 사용하게 되면 (call3()유형이라면) 맨 마지막 요소가 삭제됨.
     .pop(인덱스넘버)로 작성하면 해당 인덱스의 마지막 요소를 삭제함
     - .remove('값') - list 내에 해당하는 값을 찾아 삭제함(argument로 인덱스 넘버를 요구하는게 아니라 특정 데이터를 요구한다고 볼 수 있습니다.) - 교제에는 없는 메서드

list 예시
```python
# list의 선언 및 초기화
li1 = [1,2,3,'김사']

# 인덱스 / 마이너스 인덱스
print(li1[0])
print(li1[1])
print(li1[2])
print(li1[3])
print(li1[-1])
print(li1[-2])
print(li1[-3])
print(li1[-4])

# slice
li2 = [100, 3.14, 'hello']      # list 선언 및 초기화 방법 # 1
li3 = list([4,5,6,7,8,9,0])     # list 선언 및 초기화 방법 # 2
print(li3[0:4:2])       # 0번지부터 4번지 앞까지, 2씩 증가시키면서. # 결과값 : [4 , 6]

# list element의 추가와 삭제

# 추가
scores = [30, 40, 50]
print(scores)
scores.append(100)
print(scores)
scores.insert(0, 90)
print(scores)

# 삭제
print(scores.pop()) # 근데 .pop()은 cala3() 유형입니다. 즉 return값이 있는데, 그 삭제한 element가 return되기 때문에 print(scores.pop())은 현재 scores의 맨 마지막 element인 100이 콘솔에 출력됩니다.
print(scores.pop(0))    # 결과값 : 90
print(scores.remove(50))        # 결과값 : None / 특정 값을 바로 삭제 했으니까요.
print(scores)                   # 결과값 : [30, 40]
```
연습 예제
li4 리스트를 선언하고, 1 부터 10 까지 집어넣어 보세요.
print(li4) 결과값은 [1,2,3,4,5,6,7,8,9,10]
```python
li4 = []
for i in range(10):
    li4.append(i+1)
print(li4)
```
각 list 내의 element들을 뽑아내서 *2씩 시키겠습니다.
일반 for문 형식으로 한 번
enhanced for문 형식으로 한 번 해서 첫 번 째 element가 4가 되어야 되겠습니다.
```python
li4 = []
for i in range(10):
    li4.append(i+1)
print(li4)
for i in range(len(li4)):
    new_element = li4[i]*2
    print(li4[i]*2, end=' ')        # 이거 element를 뽑아서 2를 곱한거지 li4를 바꾼게 아니라서 그렇습니다.
    li4[i] = new_element
print()
print(li4)
print()     # 개행을 위한 빈 print() 함수 호출
for element in li4:
    print(element*2, end=' ')

for i in range(len(li4)):
    new_element = li4[i]*2
    li4[i] = new_element
print(li4)
n = 0
for element in li4:
    li4[n] = element*2
    n += 1
print(li4)
```

2. tuple 튜플
저장된 값을 변경할 수 없는 list라고 생각하시면 됩니다. 순서는 있기 때문에 index 넘버와 slicing은 가능하지만 저장된 값 이외에는 추가 / 수정 / 삭제가 불가능.
소괄호를 통해서 생성한다.

tuple 예시
```python
tu1 = (1,2,3)           # 튜플 생성 방법 # 1
tu2 = tuple((4,5,6))    # 튜플 생성 방법 # 2
tu3 = 7,8,9             # 튜플 생성 방법 # 3      근데 얘는 변수 하나에 데이터가 여러개 입니다.

a,b,c = 7,8,9           # 복수의 변수 선언 및 초기화 방법 -> 즉 변수 개수와 데이터 개수가 같으면 가능
print(a)
print(b)
print(c)

tu4 = 0             # 그럼 얘의 자료형은 뭘까요
print(type(tu4))    # 결과값 : <class 'int'>
# tu4라고 해서 저희는 튜플로 생각하고 변수명을 지었지만 실제로는 그냥 int 변수명이겠죠.

tu5 = 1,2,3,4,5,6,7,8,9,10
print(type(tu5))

tu6 = 'hello','good morning','my name is','kim-il','i am','20 ','years old.'
for word in tu6:
    print(word.title(), end='')      # 결과값 : HelloGood MorningMy Name IsKim-IlI Am20 Years Old.

print()
print(tu6)
```
이상의 tu6의 예시에서 중요한 점은 collection의 개념과 내부 element의 자료형이 서로 다르다는 점입니다. tuple의 정의는 내부 element의 추가 / 수정 / 삭제가 불가능한 collection이지만, element들은 가공이 가능합니다.
가공해서 tuple에 대입하는 것이 불가능하겠죠. 수정이 안되니까.

3. set
수학의 집합 개념. Java에서랑 같습니다.
list / tuple은 index가 존재한다고 했습니다. 이 두 개를 sequence라고 하고, set / dictionary 의 경우에는 index가 없어서 비시퀀스라는 표현을 씁니다. slicing은 사용을 못합니다.
   - element 관련 메서드
       1. .add() - set에 새로운 element 추가
       2. .remove() - 기존 element 삭제('값을 정확하게 입력'해야만 한다.)
       3. .discard() - 기존 element 삭제(element로 정확한 값이 없으면 그냥 종료됩니다.)

set 예시
```python
# set 생성
set1 = {1,2,3}      # 세트 생성 방법 # 1
set2 = set({4,5,6}) # 세트 생성 방법 # 2

print(set1)
print(set2)

# 굳이 # 1, 2를 나눈 이우 : 비어있는 list / tuple / set 생성 방법
li = []
tu = ()
se = {}

print(type(li))         # 결과값 : <class 'list'>
print(type(tu))         # 결과값 : <class 'tuple'>
print(type(se))         # 결과값 : <class 'dict'>

se2 = set({})       
print(type(se2))    # 결과값 : <class 'set'>
```
se = {} 형태로 비어있는 set을 생성했을 경우 se는 사실 <class 'dict'>로 나옵니다. set 자료형이 아닌 dictionary 자료형으로 생성됩니다. 그래서 비어있는 set를 생성하기 위해서는 반드시 # 2 방식(`se2 = set({})`)으로 만들어줘야 합니다.
```python
# element 관련 method
# 생성
se3 = {10,20,30}
se3.add(50)
print(se3)      # 결과값 : {10, 20, 50, 30} - 순서가 없어서 다르게 나올 수 있음
se3.remove(30)  # 순서가 없기 때문에 '값'을 정확하게 입력해야만 합니다.
print(se3) # 결과값 : {10,20,50}

# 제거

# remove vs. discard()
# se3.remove(70)        # 오류 발생 - '값을 정확하게 입력'해야만 한다고 했으니까요.
se3.discard(70)         # 얘는 오류 발생 안합니다. .discard()는 element로 정확한 값이 없으면 그냥 종료됩니다.
print(se3)

# 향상된 for문으로 element를 추출할 수 있습니다. 순서는 보장 못한다.
for element in se3:
    print(element)

# 오류 발생 예제
# for i in range(len(se3)):
#     print(se3[i])

```

4. dict(dictionary) - Java에서의 Map / Js에서의 Object / JSON과 같은 형식입니다.  (key - value가 있다)
   1) dictionary에서 property 추가 / 삭제

dictionary 예시
```python
dict1 = {
    '이름' : '김일',
    '나이' : 20,
    '주소' : ['서울특별시','마포구','목동'],
}
```
list의 element 추출 반복문 작성
```python
li01 = [10,20,30,40]
for num in li01:
    print(num)
```
dictionary에서 같은 방식의 반복문을 활용하게 될 때, dictionary/JS Object에서 향상된 for문으로 반복문 돌리면 key가 빠져나옵니다. (매우 중요)
그래서 `딕셔너리명[key]`로 작성해주셔야 value를 조회할 수 있습니다.
```python
dict1 = {
    '이름' : '김일',
    '나이' : 20,
    '주소' : ['서울특별시','마포구','목동'],
}

for key in dict1 :
    print(key)
    print(dict1[key])

# key들만 추출하는 메서드
print(dict1.keys())             # 결과값 : dict_keys(['이름', '나이', '주소'])
print(type(dict1.keys()))       # 결과값 : <class 'dict_keys'>


# value들만 추출하는 메서드
print(dict1.values())           # 결과값 : dict_values(['김일', 20, ['서울특별시', '마포구', '목동']])
print(type(dict1.values()))     # 결과값 : <class 'dict_values'>

# key들만 뽑아서 list를 만든다든지 / value들만 뽑아서 list를 만들고 싶다면 형변환함수를 사용해야함.

keys = list(dict1.keys())
values = list(dict1.values())
print(keys)                 # 그럼 이제는 인덱스로 추출하는 것이 가능하겠죠.
print(values)

```
그래서 collections 수업 상황에서 매우 중요한 것은 list를 배웠을 때 list만 생각할 것이 아니라, set이나 tuple, dictionary로 자료형 변경이 가능한가, 어떤식으로 가능한가, 어떨 때 써야하는가와 같이 종합적인 고려를 하는 역량이 데이터를 다룰 때 중요하다고 할 수 있겠습니다.
### dictionary에서 property 추가 / 삭제
```python
dict1 = {
    '이름' : '김일',
    '나이' : 20,
    '주소' : ['서울특별시','마포구','목동'],
}

dict1['직업'] = '웹 퍼블리셔'      # 기존에 없는 key를 입력하고 = value 저정하면 됩니다.
print(dict1)
dict1['직업'] = '웹 개발자'        # key 하나당 value는 고정이기 때문에 재대입이 이루어집니다.
print(dict1)
# 삭제 방법
print(dict1.pop('직업'))                 # key를 알아야지 삭제 가능 / .pop()의 return 특성이 중요합니다.
print(dict1)
```
응용 예제 # 1

list [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]의 3번째 요소로부터 7번째 요소만 추출한 결과, 그리고 그 list에서 2 번째 요소를 출력하는 프로그램을 작성하시오.

실행 예
3 번째 요소로부터 7 번째 요소 = [ 30, 40, 50, 60, 70]
3 번째 요소로부터 7 번째 요소 중 2 번째 요소 = 40
```python
li001 = []
for num in range(1,11) :
    li001.append(num*10)
# 일반적인 강의에서 하는 단계별 slicing / 추출
list_sliced = li001[2:7]
print(f'3 번째 요소로부터 7 번째 요소 = {list_sliced}')
print(f'3 번째 요소로부터 7 번째 요소 중 2 번째 요소 ={list_sliced[1]}')

print(f'3 번째 요소로부터 7 번째 요소 = {li001[2:7]}')
print(f'3 번째 요소로부터 7 번째 요소 중 2 번째 요소 = {li001[2:7][1]}')

```
응용 예제 # 2

사용자로부터 1에서 12사이의 월을 입력 받아, 해당 월이 며칠까지 있는지 출력하는 프로그램을 작성하시오.
(윤년은 고려 x)

실행 예
1 ~ 12 사이의 월을 입력하세요 >>> 2
2월은 28일까지입니다.
```python
# # 1 : ditionary 이용 방법
# # 2 : list를 이용하는데, [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]을 이용하는 방법
# # 3 : list를 이용하는데, [28, 30, 31]을 이용하는 방법

# # 1 : ditionary 이용 방법
year = {
    '1' : 31,
    '2' : 28,
    '3' : 31,
    '4' : 30,
    '5' : 31,
    '6' : 30,
    '7' : 31,
    '8' : 31,
    '9' : 30,
    '10' : 31,
    '11' : 30,
    '12' : 31,
}
month = int(input('1 ~ 12 사이의 월을 입력하세요 >>> '))
day1 = list(year.values())[month-1]
print(f'{month}월은 {day1}일 까지 입니다.')

month1 = input('1 ~ 12 사이의 월을 입력하세요 >>> ')
print(f'{month1}월은 {year[month1]}일 까지 입니다.')

# # 2 풀이 방법
year1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
print(f'{month1}월은 {year1[int(month1)-1]}일 까지 입니다.')

# # 3 풀이 방법
year2_list = [28, 30, 31]

month_int = int(input('1 ~ 12 사이의 월을 입력하세요 >>> '))
if month_int == 2:
    year2 = year2_list[0]
elif month_int == 4 or month_int == 6 or month_int == 9 or month_int == 11:
    year2 = year2_list[1]
elif month_int in [1,3,5,7,10,12]:
    year2 = year2_list[2]
else :
    print('잘못 입력하셨습니다.')
    year2 = 'x'
print(f'{month_int}월은 {year2}일 까지 입니다.')
```

이상의 코드 라인에서 중요한 것은 in 개념입니다.
in 뒤에는 다양한 것들이 올 수 있는데, 특히 반복가능객체(iterable)이 올 수 있다는 점 입니다.
그래서
elif month_int in [1,3,5,7,10,12]:
    year2 = year2_list[2]
의 해석 부분이 중요한데, in 다음에 임의의 list를 초기화하여 month_int가 임의의 list의 element값을 가지고 있는지 여부를 조건 검토했다고 해석할 수 있겠습니다.

(1,3,5,7,8,10,12) 이렇게 초기화 하더라도 전혀 문제가 없겠네요. tuple로 집어넣은 사례가 되겠습니다.

응용 예제 # 3

수학 여행을 어디로 갈 지 결정하기 위해 학생들이 희망하는 모든 수학 여행 장소를 조사하기로 했습니다.
학생들이 원하는 장소를 입력받아 동일한 입력을 무시하고 모든 입력을 저장하려고 합니다.
학생을 3 명으로 가정하고 실행 예와 같이 동작하는 프로그램을 작성하시오.

실행 예

희망하는 수학여행지를 입력하세요 >>> 제주 
희망하는 수학여행지를 입력하세요 >>>  제주
희망하는 수학여행지를 입력하세요 >>>  민속촌

조사된 수학여행지는 {'제주','민속촌'}입니다.
조사된 수학여행지는 ['제주','민속촌']입니다.
```python
li_place = []

for i in range(3) :
    place = input('희망하는 수학여행지를 입력하세요 >>> ')
    li_place.append(place)
print(f'조사된 수학여행지는 {set(li_place)}입니다.')
print(f'조사된 수학여행지는 {list(set(li_place))}입니다.')
```
응용 예제 # 4

짝수만 추출하기

사용자로부터 임의의 양의 정수를 입력 받고, 그 정수만큼 숫자를 입력 맏아 list에 저장하세요.
이 후 저장된 숫자 중 짝수만 새로운 list에 저장하여 출력하는 프로그램을 작성하세요.

실행 예
몇 개의 숫자를 입력할까요? >>> 5
1번째 숫자를 입력하세요 >>> 10
2번째 숫자를 입력하세요 >>> 15
3번째 숫자를 입력하세요 >>> 20
4번째 숫자를 입력하세요 >>> 25
5번째 숫자를 입력하세요 >>>  30
입력 받은 숫자는 [5,10,15,20,25,30]입니다.
입력 받은 숫자들 중 짝수는 [10, 20, 30] 입니다.
```python
number_list = []
number_list2 = []
order = input('몇 개의 숫자를 입력할까요? >>> ')
for i in range(int(order)):
    num = input(f'{i+1}번째 숫자를 입력하세요 >>> ')
    number_list.append(num)
    if int(num) % 2 == 0:
        number_list2.append(num)

print(f'입력 받은 숫자는 {number_list}입니다.')
print(f'입력 받은 숫자들 중 짝수는 {number_list2}입니다.')
```
응용 예제 # 5

딕셔너리 기반의 연락처 관리

사용자로부터 3 명의 이름과 전화번호를 입력받아 딕셔너리에 저장한 뒤, 입력한 정보를 추출하는 프로그램을 작성하시오.

실행 예
1 번째 사람의 이름을 입력하세요 >>> 김일 
1 번째 사람의 연락처를 입력하세요 >>> 010-1234-5678
2 번째 사람의 이름을 입력하세요 >>> 김이
2 번째 사람의 연락처를 입력하세요 >>> 010-2345-6789
3 번째 사람의 이름을 입력하세요 >>> 김삼
3 번째 사람의 연락처를 입력하세요 >>> 010-3456-7890
입력 받은 연락처는 {'김일':'010-1234-5678','김이':'010-2345-6789','김삼':'010-3456-7890'}입니다.
```python
people_dict = {}

for i in range(int(input('입력받을 사람의 수를 입력하세요 >>> '))):
    name = input(f'{i+1} 번째 사람의 이름을 입력하세요 >>> ')
    call = input(f'{i+1} 번째 사람의 연락처를 입력하세요 >>> ')
    people_dict[name] = call
print(f'입력 받은 연락처는 {people_dict}입니다.')

```
응용 예제 # 6

숫자를 입력하는 횟수만큼 비어있는 list에 숫자를 추가하기
문제 : 비어있는 numbers1을 선언하고, 그 안에 입력 받은 횟수 만큼 숫자를 추가히시오.

함수 정의 : add_numbers()
매개 변수 : 정수 n

함수 호출
add_numbers(last_num)           call2()유형
print(add_numbers(last_num))    call4()유형

실행 예
숫자 몇 까지 입력하시겠습니까? >>> 10
[1,2,3,4,5,6,7,8,9,10]
[1,2,3,4,5,6,7,8,9,10]
```python
number = int(input('숫자 몇 까지 입력하시겠습니까? >>> '))
def add_numbers1(last_num):
    numbers = []
    for i in range(number):
        numbers.append(i+1)
    print(numbers)

add_numbers1(number)

def add_numbers2(last_num):
    numbers = []
    for i in range(number):
        numbers.append(i+1)
    return numbers
print(add_numbers2(number))

def add_numbers3(last_num):
    hello = ['안', '녕', '하', '세', '요']
    numbers = []
    for i in range(last_num):
        numbers.append(i+1)

    for j in range(len(hello)):
        numbers.insert(number + j, hello[j])
    print(numbers)

add_numbers3(number)

def add_numbers4(last_num, temp_list):
    numbers = []
    for i in range(last_num):
        numbers.append(i+1)
    result = numbers + temp_list
    print(result)

hello = ['안', '녕', '하', '세', '요']
add_numbers4(number,hello)

```
응용 예제 # 7

짝수와 홀수의 개수 세기
list를 입력 받아 짝수와 홀수의 개수를 세는 함수를 작성하시오.

함수 정의
함수 이름 : count_even_odd
매개 변수 : list_numbers(요소는 모두 정수일 것)

함수 호출
count_even_odd([1,2,3,4,5,6,7,8,9,10])

실행 예
짝수의 개수 : 5개
홀수의 개수 : 5개
```python

def count_even_odd(list_numbers):
    numbers = []
    for i in range(len(list_numbers)):
        numbers.insert(i, list_numbers[i])
        for j in range(len(numbers)):
            if numbers[j] % 2 == 0:
                count_num = numbers.count(list_numbers[j])
    print(count_num)

count_even_odd([1,2,3,4,5,6,7,8,9,10])

def count_even_odd1(numbers):
    even_count = 0
    odd_count = 0
    for number in numbers:
        if number % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    print(f'짝수의 갯수 : {even_count}')
    print(f'홀수의 갯수 : {odd_count}')

count_even_odd([1,2,3,4,5,6,7,8,9,10])

def count_even_odd3(numbers):
    evens = []
    odds = []
    for number in numbers:
        if number % 2 == 0:
            evens.append(number)
        else :
            odds.append(number)
    print(f'짝수의 갯수 : {len(evens)}')
    print(f'홀수의 갯수 : {len(odds)}')

count_even_odd3([1,2,3,4,5,6,7,8,9,10])

def count_even_odd4(numbers):
    evens = []
    for number in numbers:
        if number % 2 == 0:
            evens.append(number)
    print(f'짝수의 갯수 : {len(evens)}')
    print(f'홀수의 갯수 : {len(numbers) - len(evens)}')

count_even_odd4([1,2,3,4,5,6,7,8,9,10])
```

## classes
클래스 정의 형식 :

class 클래스명(파스칼 케이스로) :
    본문

객체 생성 형식 :
객체이름 = 클래스명()

클래스 정의 형식 예시
```python
class WaffleMachine:
    pass
```
객체 생성 예시
```python
waffle = WaffleMachine()
print(waffle)       # 결과값 : <__main__.WaffleMachine object at 0x00000225893E1400>
```
클래스의 구성

1. 클래스의 기본 구성
    객체를 만들어내는 클래스는 객체가 가져야 할 구성 요소를 지닙니다.(Java 때 방이 가져야 할 구성요소는 무엇이었냐고 질문했었습니다.)
    객체를 생성하기 위해서는 객체가 가져야 할 '값'과 '기능'을 지녀야 합니다.
    
    값 = 속성(attribute)
    기능 = 메서드(method)
    
    클래스를 구성하는 속성은 두 가지로 구분됩니다.,
        1) 클래스 변수 : 클래스를 기반으로 생성된 모든 인스턴스 들이 공유하는 변수(Java에서는 얘를 static 변수라고 했습니다)
        2) 인스턴스 변수 : 인스턴스들이 개별적으로 가지는 변수
    
    메서드는 특징에 따라서
        1) 클래스 메서드
        2) 정적 메서드
        3) 인스턴스 메서드
    입니다, Java에서는 정적 메서드라고 하던게 클래스 메서드에 해당되고, 정적 메서드는 또 따로 있다고 볼 수도 있고 Java의 정적 메서드가 파이썬의 클래스메서드 + 정적메서드라고 볼 수도 있습니다.
    
    그리고 Java에서는 this 썼는데(아직 생성되지 않은 객체명을 도입할 수 없으니 사용 하는 키워드), python에서는 self 씁니다. 예시 보여드리겠습니다.
    
    self 키워드
    인스턴스 변수에서 각가의 객체를  의미하기 위해서 self 키워드를 붙여줍니다.
    인스턴스 메서드에서의 첫 번쨰 매개변수로 '항상' self를 추가해야 합니다.

응용 예제 # 1

```python
# 클래스 정의
class Person :
    # 메서드 정의(함수가 클래스 내에 있으니까요)
    def set_info(self, name, age, tel, address):   # call2() / setter죠
        self.name = name
        self.age = age
        self.tel = tel
        self.address = address

    def show_info(self):            # call1()
        print(f'이름:{self.name}')
        print(f'나이:{self.age}')
        print(f'연락처:{self.tel}')
        print(f'주소:{self.address}')

    def show_info2(self) :
        return f'제 이름은 {self.name}이고, {self.age}살 입니다. \n연락처는 {self.tel}인데, {self.address}에 살고 있습니다.'


# 객체 생성
person01 = Person()
# Person 클래스의 메서드 호출
person01.set_info('김일',20,'010-1234-5678','서울특별시 마포구')
person01.show_info()
```
응용 예제 # 2

person02 객체를 생성하고, person02.set_info()를 활용하여 여러분 이름 나이 연락처 주소를 입력하고
show_info2()(call3() 유형으로 작성)를 정의하여 다음 실행 예와 같이 출력되도록 작성하시오.
실행 예
제 이름은 ___이고, __살 입니다.
연락처는 ___인데, ___에 살고 있습니다.
코드 실행
print(person02.show_info())
```python
person02 = Person()
person02.set_info('김이', 22, '010-2345-6789','경상남도 창원특례시')
print(person02.show_info2())
```
이전에는 일종의 setter를 활용하여 속성에 값을 넣어줬습니다.
그럼 Java에서 수업한 것처럼 속성값이 대입되지 않은 객체를 생성한 다음에 속성값을 집어넣어주는 과정을 거쳐야 합니다.

근데 매개변수 생성자를 정의해버리면 객체 생성시에 속성값을 넣을 수 있겠네요.
```python
class Candy :
    def set_info(self, shape, color) :
        self.shape = shape
        self.color = color

    def show_info(self) :
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')

# 객체 생성 ( 빈 객체 -> 속성값 대입 -> 속성값 출력)
satang = Candy()
satang.set_info('구형','갈색')
satang.show_info()
```
이게 굳이 속성값에 대한 제한이 있지 않다면 빈 객체 만들어 놓고 거기에 값 대입하는게 비효율적으로 느껴집니다. 그래서 저희는 생성자를 도입할 겁니다.

Java / JS 등에서는 생성자 명은 클래스 명과 동일하거나 constructor인데, 또 python만 지 혼자서 이상한 걸로 생성자를 만듭니다.
```python
class Candy2 :
    # 생성자 정의
    def __init__(self, shape, color) :
        self.shape = shape
        self.color = color

    def show_info(self) :
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')

# 객체 생성 방식에서의 차이가 있습니다.
satang2 = Candy2('정육면체', '흰색')
satang2.show_info()

class Sample:
    # 생성자 정의
    def __init__(self):
        print('인스턴스가 생성되었습니다.')

    # 소멸자 정의
    def __del__(self):
        print('인스턴스가 소멸되었습니다.')

# 객체 생성
sample = Sample()
print()
# 객체 소멸자 호출 방법
del sample      # del 객체명
print('객체 지운 후의 코드라인입니다.')
```
굳이 소멸자를 학습하는 이유 -> 객체가 생성되면 메모리 공간을 차지해서, 객체가 호출될 때마다 그곳에서 불려나오게 됩니다.

하지만 특정 객체가 일정 코드라인 이후로 전혀 사용되지 않을 때에도 여전히 메모리를 차지하기 때문에 소멸자를 통해서 강제로 삭제해주면 메모리 관리가 편하겠네요.

그럴 때 씁니다. -> 저희 프로젝트 때는 뭐 굳이 안 쓸 것 같습니다.

기본 예제

생성자를 이용해서 용량을 가진 usb 인스턴스를 만드는 프로그램을 작성하시오.

지시 사항
1. 클래스 USB를 정의할 것
2. 생성자를 정의하여 매개변수로 capacity를 받을 것
3. get_info() 메서드를 정의할 것

main 단계 코드
usb = USB(64)
usb.get_info()

실행 예
USB 객체가 생성되었습니다.
64GB USB
```python
class USB :
    def __init__(self, capacity) :
        self.capacity = capacity
        print('USB 객체가 생성되었습니다.')

    def get_info(self) :
        print(f'{self.capacity}GB USB')

usb = USB(64)
usb.get_info()
```
응용 예제

1. 다음 지시 사항을 읽고 이름을 저장하는 Person 클래스를 생성하시오

지시 사항

1. 다음과 같은 방법으로 man과 woman 인스턴스를 생성하시오
man = Person('james')
woman = Person('emily')
2. man과 woman 인스턴스가 생성되면 다음과 같은 메시지를 출력할 수 있도록 작성하시오
james is born.
emliy is born.

3. 다음과 같은 방법으로 man 인스턴스를 삭제하시오.
del man

4. 인스턴스가 삭제되면 다음과 같은 메시지를 출력할 수 있도록 작성하시오
james is dead

```python
class Person :
    def __init__(self, name) :
        self.name = name
        print(f'{self.name} is born.')

    def __del__(self):
        print(f'{self.name} is dead.')

man = Person('james')
woman = Person('emily')
del man
```
### python 판 getter / setter

setter는 call2() -> 매개변수 o / 리턴 x
getter는 call3() -> 매개변수 x / 리턴 o

```python
class Student :
    # setter들 정의
    def set_name(self, name) :
        self.name = name

    # getter 예시
    def get_name(self) :
        return self.name
```
응용 예제

지시 사항 age / address / score 속성을 setter를 통해서 추가하시오.
이상의 속성에 맞는 getter도 추가하시오.

student1 객체를 생성하고,
김일, 20, 4.5를 각각 이름/나이/점수에 대입하시오.

getter만을 활용하여, 
김일 학생의 나이는 20살로, 파이썬 과목의 점수는 4.5점 입니다. 라고 출력하시오.
```python
class Student1 :
    def set_name(self, name) :
        self.name = name

    def get_name(self) :
        return self.name

    def set_age(self, age) :
        self.age = age

    def get_age(self) :
        return self.age

    def set_address(self, address) :
        self.address = address

    def get_address(self) :
        return self.address

    def set_score(self, score) :
        self.score = score

    def get_score(self) :
        return self.score

    def get_info(self) :
        return f'{self.name}학생의 나이는 {self.age}살로, 파이썬 과목의 점수는 {self.score}점 입니다.'

student1 = Student1()
student1.set_name('김일')
student1.set_age(20)
student1.set_score(4.5)
print(student1.get_info())
print(f'{student1.get_name()}학생의 나이는 {student1.get_age()}살로, 파이썬 과목의 점수는 {student1.get_score()}점 입니다.')
```
응용 예제

그렇다면 Java를 기준으로 봤을 때 setter 내부에는 비지니스 로직이 들어갈 수 있었습니다.

완전 동일하게 할 겁니다.

set_age()의 경우에 내부 로직으로 0살 미만과 200살 초과의 나이는 입력이 불가능하게끔 하겠습니다.

set_score의 경우에도 0.0미만과 4.5초과는 입력이 불가능 하게끔 비지니스 로직을 작성하세요.

여기서 생기는 의문점은 그겁니다. -> 아니 매개변수 생성자를 통해서 생성했는데 객체 생성 시점에 -102살 입력하면 되는거 아니냐 할 수 있는데 추후 설명하겠습니다.

```python
class Student2 :
    def set_name(self, name) :
        self.name = name

    def get_name(self) :
        return self.name

    def set_age(self, age) :
        if age < 0 or age > 200 :
            print('0살 미만과 200살 초과의 나이는 입력이 불가능합니다.')
            return      # 메서드에 return하고 비워두면 메서드 종료라는 의미
        self.age = age

    def get_age(self) :
        return self.age

    def set_address(self, address) :
        self.address = address

    def get_address(self) :
        return self.address

    def set_score(self, score) :
        if score < 0.0 or score > 4.5 :
            print('0.0미만과 4.5초과는 입력이 불가능합니다.')
        else :
            self.score = score

    def get_score(self) :
        return self.score

    def get_info(self) :
        return f'{self.name}학생의 나이는 {self.age}살로, 파이썬 과목의 점수는 {self.score}점 입니다.'

student2 = Student2()
student2.set_name('김일')
student2.set_age(20)
student2.set_score(4.5)
print(student2.get_info())
print(f'{student2.get_name()}학생의 나이는 {student2.get_age()}살로, 파이썬 과목의 점수는 {student2.get_score()}점 입니다.')
```