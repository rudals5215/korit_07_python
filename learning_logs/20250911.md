# 금일 복습 목록
- 목록
  1. prettytable
  2. exception
  3. inheritance

# Prettytable
외부 패키지의 설치 # 1 : settings를 통한 방법
project : 프로젝트명 으로 되어있는 부분 클릭
-> python interpreter 클릭
-> 패키지 검색 및 설치

외부 패키지의 설치 # 2 : 터미널을 이용하는 방법
pip install prettytable

### `field_names`
이 메서드는 테이블의 필드 이름(열 헤더)을 설정하거나 가져오는 데 사용됩니다.

**사용법:**
```python
table = PrettyTable()
table.field_names = ["필드1", "필드2", "필드3"]
```

**설명:**
- **필드 이름 설정:** `field_names`에 문자열 리스트를 할당하여 테이블의 헤더를 정의할 수 있습니다.
- **필드 이름 가져오기:** `field_names`를 액세스하면 현재 헤더를 가져올 수 있습니다.

### `add_row`
이 메서드는 테이블에 단일 행을 추가하는 데 사용됩니다.

**사용법:**
```python
table.add_row(("값1", "값2", "값3"))
```

**설명:**
- **행 추가:** `field_names`에 정의된 각 필드에 해당하는 값 리스트를 제공해야 합니다. 리스트의 값 개수는 필드 이름의 개수와 일치해야 합니다.

```python
pokemon_data = [
    (1, "이상해씨", "풀/독"),
    (2, "이상해풀", "풀/독"),
    (3, "이상해꽃", "풀/독"),
    (4, "파이리", "불꽃"),
    (5, "리자드", "불꽃"),
    (6, "리자몽", "불꽃/비행"),
    (7, "꼬부기", "물"),
    (8, "어니부기", "물"),
    (9, "거북왕", "물"),
    (10, "캐터피", "벌레"),
    (11, "단데기", "벌레"),
    (12, "버터플", "벌레/비행"),
    (13, "뿔충이", "벌레/독"),
    (14, "딱충이", "벌레/독"),
    (15, "독침붕", "벌레/독"),
    (16, "구구", "노말/비행"),
    (17, "피죤", "노말/비행"),
    (18, "피죤투", "노말/비행"),
    (19, "꼬렛", "노말"),
    (20, "레트라", "노말"),
    (21, "깨비참", "독"),
    (22, "독파리", "독/비행"),
    (23, "아보", "독"),
    (24, "아보크", "독"),
    (25, "피카츄", "전기"),
    (26, "라이츄", "전기")
]
```
pokemon_data
```python
from prettytable import PrettyTable
from pokemon_data import pokemon_data

# PrettyTable의 객체 생성
table = PrettyTable()

table.field_names = ['이름','나이','주소']
print(table)

pokemon_table = PrettyTable()
pokemon_table.field_names =['번호','이름','타입']
# # 1
for pokemon in range(len(pokemon_data)):
    pokemon_table.add_row(pokemon_data[pokemon])
print(pokemon_table)

# # 2
for pokemon in pokemon_data:
    pokemon_table.add_row(pokemon)
    print(pokemon)

# # 3
pokemon_table.add_rows(pokemon_data)
print(pokemon_table)
```
# Exception
## 예외 처리
```python
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는수를 정수로 입력하세요 >>> '))
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
except Exception as e :
    print(e)
else :
    print(f'b / a = {b/a}')
finally:
    print('프로그램이 종료되었습니다.')
```
이상의 상황에서 ZeroDivisionError를 예외 처리했음에도 불구하고
a = 0
b = 아무 정수
를 넣었을 때 ZeroDivisionError 가 예외 처리되지 않고 오류 발생을 하는 것을 확인할 수 있습니다.
어떻게 처리를 해야할까
```python
# 내가 작성한 방법
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는수를 정수로 입력하세요 >>> '))
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
except Exception as e :
    print(e)
else :
    if not ZeroDivisionError : 
        print(f'b / a = {b/a}')
finally:
    print('프로그램이 종료되었습니다.')
    
# # 강사님 풀이 1
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는수를 정수로 입력하세요 >>> '))
    result = b / a      # 예외가 발생할 수 있는 구간이 try문 내에 있어야만 합니다.
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
except Exception as e :
    print(e)
else :
    print(f'b / a = {result}')
finally:
    print('프로그램이 종료되었습니다.')

# # 강사님 풀이 2
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는수를 정수로 입력하세요 >>> '))
    print(f'b / a = {b / a}')
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
except Exception as e :
    print(e)
else :
    print(f'프로그램이 정상 종료 되었습니다.')
finally:
    print('프로그램이 종료되었습니다.')
```
결과적으로 개발자가 고려해야 할 것은 일단 try를 써버리면 except 안 썼을 때 오류가 발생하기 떄문에 try / except문이 없는 상태에서 다양하게 검증해보고 어떤 예외가 발생하는지 체크 해야 합니다.
그리고 그 발생한 예외들에 대한 except문을 작성해야 하고, 정상적으로 처리가 되었을 때 else문을 쓸 필요가 있을겁니다.

하지만 이상의 사례와 같이 a = 0을 입력하는 것 자체가 예외를 발생시키지 않고,
1. a = 0 이면서,
2. b / a 연산을 시도할 때 ZeroDivisionError가 발생하기 때문에

else 문에 b / a 가 포함되어서는 안됩니다.
그래서 try문 내에 result = b / a 를 집어넣어줌으로써 그 부분이 예외 없이 통과되었을 때만 연산 결과가 출력될 수 있도록 `pring(f'b / a = {reuslt}')`로 정리했습니다.

# 상속 (Inheritance)
```python
class Person:
    def __init__(self, name):
        self.name = name
    
    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')

class Student(Person):
    def __init__(self, name, school):
        super().__init__(name)
        self.school = school
    
    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다.')

# 객체 생성
potter = Student('해리포터','호그와트')
potter.eat('감자')
potter.study()
```
이상의 코드에서 주목해야 할 점은
1. Student 클래스에 정의되지 않은 메서드인 .eat()을 호출했다는 점 `potter.eat(감자)`
2. Student 클래스의 생성자에서 확인되는 `super().__init__(name)` 입니다.
    - 해당 부분은 슈퍼 클래스의 생성자를 호출하는 방식입니다.
    - Java에서는 슈퍼 클래스의 생성자 호출 방식이 super()
    - Java에서 슈퍼 클래스의 메서드 호출 방식 super.메서드명()
```python
    def eat(self, food):
        print(f'{self.school}에서', end=' ')
        super().eat(food)
```
만약에 이상과 같이 슈퍼 클래스의 메서드인 .eat()을 override하여 `재정의` 하는 것도 가능합니다.
Java와 달리 python에서는 기본적으로 `super().`을 베이스로 한다는 것을 알 수 있습니다.
생성자나 소멸자가 `__` 가 앞뒤로 붙기는 하지만 기본적으로 method라는 사실을 알고 계신다면 Java보다 오히려 더 일괄적인 방식으로 코드를 작성한다는 점도 확인할 수 있겠습니다.
