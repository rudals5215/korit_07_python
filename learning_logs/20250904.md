# 금일 복습 목록
- 목록
  1. functions
  2. hangman
  3. collection

## function
1. 함수의 종류
    1) 파이썬 내장 함수
    2) 메서드 (methods)
    3) 사용자 장의 함수

2. 함수 용어 정리
    1) 함수 정의 : 사용자 함수를 새로 만드는 것을 의미 (def : define)
    2) 인수 (argument) : 함수에 전달 할 입력값 (input)
    3) 매개변수(parameter) : 인수를 받아서 저장하는 변수를 의미
    4) 반환값 / 결과값 / 리턴값 : 함수의 출력값 (output)
    5) 함수 호출 (call) : 함수를 실제로 사용하는 것을 의미

3. (사용자) 함수의 형식 :
def 함수_이름(매개변수1, 매개변수2) :
    실행문
    return 어쩌고

변수 = 함수_이름(argument1, argument2)

```python
# 함수 정의
def display_name(name):
    print(f'당신의 이름은 {name}입니다.')

# 함수 호출
display_name('김일')

def display_name_age(name, age):
    print(f'당신의 이름은 {name}이고, 나이는 {age}살 입니다.')

display_name_age('김이',30)
display_name_age(age=23, name='김삼') # keyword argument
```
우리가 예를 들어 input('이름을 입력하세요 >>> ')을 이용해서 이것을 name이라는 변수에 담았다고 가정하면,
name = input('이름을 입력하세요 >>> ')이라고 작성해 왔습니다.

그러면 여태까지 input()이라는 파이썬 내장 함수를 사용하고 있었다고 볼 수 있겠습니다. 파이썬 내장 함수는 이미 정의가 되어있고, 개발자들은 함수 호출만 잘 하면 되겠네요.

사용자 정의 함수의 경우 개발자 자신이 함수를 정의하고, 그 후에 호출까지 하는 것 까지의 과정이라고 보시면 되겠습니다.

내장함수 예시
print() / type() / int() / float() / input()

2. 메서드(methods) : 특정 객체가 가지고 있는 함수를 의미. 특정 자료형에 포함되어있는 함수. 사실 함수와 메서드는 동일한 개념이지만, 호출 방식에 있어서의 차이가 있습니다.

함수는 독립적으로 사용 가능 / 메서드는 특정 객체를 통해서만 호출 가능
```python
eng_name = input('당신의 이름을 영어로 입력하세요 >>> ')
print(eng_name)
eng_name = eng_name.upper()
print(eng_name)
```
이상의 코드는 함수 호출을 해서 그 결과값을 eng_name이라는 변수에 담았다고 볼 수 있습니다.
그리고 어제 저희가 수업한 것처럼 input()의 결과값의 자료형은 str이었죠.
그렇다면 eng_name.upper()의 경우 .upper()가 메서드에 해당하고, 해당 메서드는 str자료형에 종속되어 있다고 볼 수 있겠습니다.
그리고 그 결과값을 '다시 eng_name'이라는 변수에 담았기 때문에
55번 라인의 결과값과 57번 라인의 결과값이 차이가 생겼네요.

함수(메서드)의 유형
```python
def call1() :
    print('[ x | x ]')

# 매개변수 o / 리턴 x
def call2(unknown_parameter) :
    print('[ o | x ]')
    print(f'{unknown_parameter}라고 입력하셨나보네요')

# 매개변수 x / 리턴 o
def call3() :
    print('[ x | o ]')
    return 1

def call4(unknown1,unknown2) :
    print('[ o | o ]')
    return unknown1 + unknown2
# 함수 호출
call1()
call2('오늘의 날씨는 시원한 편')
call2(123456)
call3()         # 결과값 : [ x | o ]만 나옴
print(call3())
print(call4('안녕','하세요'))
print(call4(unknown1=1234, unknown2=5678))
```
메서드 실행 예제 # 1
700원짜리 음료수를 뽑을 수 있는 자판기 프로그램을 구현하시오. 돈을 넣으면 몇 잔의 음료수를 뽑을 수 있는지, 그리고 잔돈은 얼마인지 모든 경우의 수를 출력하도록 합니다.

함수 정의
- 반환값 : 없음(call1 ~ call4 중 어떤 유형일지 고민할 필요가 있습니다)
- 함수 이름 : vending_machine)
- 매개변수 : 정수 money

코드 구성
def vending_machine() :
    #함수 구현

vending_machine(3000)

실행 예
음료수 = 0개, 잔돈 = 3000원
음료수 = 1개, 잔돈 = 2300원
음료수 = 2개, 잔돈 = 1600원
음료수 = 3개, 잔돈 = 900원
음료수 = 4개, 잔돈 = 200원

힌트 : +, -, *, /, % 는 다 있는건데
// 이게 있습니다.

// : 몫 연산자 몫만 int로 가지고 오는 거
```python
def vending_machine(money) :
    pay = 700
    drink = 0
    while money > 0 :
        print(f'음료수 = {drink}개, 잔돈 = {money}원')
        drink += 1
        money -= pay

vending_machine(3000)
print(vending_machine(3000))

# # 강사님 풀이
my_money = 3000
drink_price = 700

# # 1 for 문으로 작성
for i in range(my_money // drink_price + 1):            # argument가 하나밖에 없다. 한계값
    print(f'음료수 개수 = {i}개, 잔돈 = {my_money-(drink_price*i)}')

# # 2 while문으로 작성
num = 0
while my_money < 0 :
    print(f'음료수 개수 = {num}개, 잔돈 = {my_money - (drink_price*num)}')
    num += 1

# 일단 for 문을 기준으로 함수화 시키겠습니다.
def vending_machine(money) :        # 이거 교제에 있는 무제 가지고 온건데 함수라는 명사라는 점에서 별로 마음에 안듭니다.
    drink_price = 700
    for i in range (money // drink_price + 1):
        print(f'음료수 개수 = {i}개, 잔돈 = {my_money - (drink_price * i)}')

def vending_machine2(money) :
    drink_price = 700
    i = 0
    while True :
        change = money - (drink_price * i)
        if change < 0 :
            break
        print(f'음료수 개수 = {i}개, 잔돈 = {change}')

vending_machine2(3000)
```
메서드 실행 예제 # 2

구구단 출력하기
함수 정의 : 
함수 이름 : multiply
매개변수 : 정수 n
리턴값 : 없음
함수 호출 : 
multiply(dan)           argument가 dan

실행 예
몇 단을 출력하시겠습니까? >>> 3
3 x 1 = 3
...
3 x 9 = 27
```python
dan = int(input('몇 단을 출력하시겠습니까? >>> '))
def multiply(dan) :
    for i in range(1,10):
        print(f'{dan} x {i} = {dan * i}')

multiply(dan)
```
메서드 실행 예제 # 3 
range() 함수의 parameter 적용 순서
1 개만 있을 때 : 한계값
2 개만 있을 때 : 시작값 , 한계값
3 개 있을 때 : 시작값, 한계값, 증감값 순서입니다.

그럼 multiply를 call2() 유형으로 정의했다고 볼 수 있겠습니다.

call1()유형으로 정의했을 때

실행 예
몇 단을 출력하시겠습니까? >>> 5
5 x 1 = 5
...
5 x 9 = 45
```python
def multiply2() :
    dan = int(input('몇 단을 출력하시겠습니까? >>> '))
    for i in range(1,10):
        print(f'{dan} x {i} = {dan * i}')

multiply2()
```

## hangman
### 사전 개념
list 내부의 element 중 하나를 임의로 선택하기 위해 random모듈 도입
```python
import random
numbers = [1,2,3,4,5]
chosen_number = random.choice(numbers)
# choice()라는 메서드의 argument로 list를 넣었습니다.
print(chosen_number)

# todo -1 : word_list에서 단어 하나를 임의적으로 선택하도록 random 모듈을 사용하고, 해당 단어를 chosen_word 변수에 담으시오
# todo -2 : 사용자에게 알파벳을 하나 추측해서 입력하라고 요청하고, 이를 guess 변수에 담으시오. 그리고 대문자로 시작하는 경우를 방지하기 위해 input() 함수 뒤에 .iower()를 적용하시오.
# todo -3 : guess에서 입력한 문자 하나가 chosen_word의 string 문자열 중에 하나의 문자와 일치하는지를 반복문을 통해 확인할 수 있도록 프로그램을 작성하시오, 맞으면 정답, 틀리면 오답이라고 출력 될 수 있도록 할 것.
word_list = ['apple','banana','camel']
chosen_word = random.choice(word_list)
print(chosen_word)
guess = input('알파벳을 입력하세요 >>> ').lower()

# # 1 enhanced - for
for letter in chosen_word:       # str의 첫 문자부터 끝까지 알아서 굴러감
    if letter == guess:
        print('정답')
    else:
        print('오답')

# # 2 일반 for
for i in range(len(chosen_word)):
    if chosen_word[i] == guess:
        print('정답')
    else:
        print('오답')
```
len() 함수 : 반복 가능 객체의 길이를 int로 return하는 함수
```python
import random
word_list = ['apple','banana','camel']
chosen_word = random.choice(word_list)
print(len(chosen_word))     # 결과값 : camel - 5
print(len(word_list))       # 결과값 : 3 -> list 내부의 element 개수가 3이니까
```
.append() - list 안에 값을 추가하는 메서드 
```python
import random

# todo -1 : 비어있는 list인 display를 만드시오.
# todo -2: 이상의 코드라인을 참조하여 chosen_word의 각 문자 개수 마다 '_'를 추가하시오. 예를 들어 chosen_word == 'apple'이라면 display = ['_', '_', '_', '_', '_']이 되어야 합니다. 즉, chosen_word의 문자 개수 만큼 '_'가 있어야 합니다.
# todo -3 : chosen_word의 각 문자들을 반복시키시오. 만약 그 위치의 문자가 guess와 일치하면, 해당 위치의 display에서 문자를 공개하시오. 예를 들어 사용자가 'p'를 입력했고, chosen_word가 apple이라면 display = ['_', 'p', 'p', '_', '_']로 바뀌어야 합니다.

word_list = ['apple','banana','camel']
chosen_word = random.choice(word_list)
# 1
display = []

# 2
for _ in range(len(chosen_word)):
    display.append('_')

# 3 
guess = input('알파벳을 입력하세요 >>> ').lower()
for i in range(len(chosen_word)):
    if chosen_word[i] == guess:
        display[i] = guess      # guess라는 데이터를 display의 인덱스 넘버인 i인 위치에 재대입
```
.join(반복가능객체) method : ','앞에 있는 문자열으르 기준으로 반복 가능 객체의 element들을 합쳐서 str로 합쳐주는 method
```python
# 예시
temp = ['배','고','프','다']
feeling = ''.join(temp)
print(temp)
print(feeling)
result = ''

for letter in temp :
    result += letter
print(result)
feeling2 = '/'.join(temp)
print(feeling2)
```
```python
import random
# todo -1 : 비어있는 list인 display를 선언하시오.
# todo -2 : chosen_word의 문자 개수 만큼 '_'를 display에 추가하시오.
# todo -3 : 사용자가 추측을 반복할 수 있도록 while 반복문을 작성하시오. 사용자가 chosen_word의 모든 문자열들을 맞추었을 때, 즉 display에 더이상 '_'가 없을 때 반복문이 멈추도록 작성할 겁니다. 반복문 종료 후 print('정답입니다!')를 출력하도록 작성하시오.
# todo -4 : 정답을 보여줄 때 apple이라면 a p p l e로 출력될 수 있도록 .join()메서드를 활용하시오.

# 1
display = []

# 2
word_list = ['apple','banana','camel']
chosen_word = random.choice(word_list)
print(chosen_word)
for _ in range(len(chosen_word)):
    display.append('_')
print(display)

# 3
while '_' in display:
# while ''.join(display) != chosen_word:
    guess = input('알파벳를 입력하세요 >>> ').lower()
    for i in range(len(chosen_word)):
        if chosen_word[i] == guess:
            display[i] = guess
            print('정답입니다!')
        elif guess not in chosen_word:
            print('오답입니다!')
    print(display)

# 4
print('정답입니다 !!')
print(' '.join(display))
```
### 행맨 만들기
```python
import random
stages = ['''
  +---+
  |   |
  O   |
 /|\  |
 / \  |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|\  |
 /    |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|\  |
      |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========''',
'''
  +---+
  |   |
  O   |
  |   |
      |
      |
=========
''', '''
  +---+
  |   |
  O   |
      |
      |
      |
=========
''', '''
  +---+
  |   |
      |
      |
      |
      |
=========
''']
# 이상의 코드라인을 확인하면 내부의 element 가 복수의 라인으로 이루이진 str인 list라고 할 수있습니다.

# todo -1 : 남은 기회 숫자를 추적하기 위한 lives 변수를 선언하고 6으로 초기화하세요.
# todo -2 : hangman03을 참조하여 while 반복문 바깥을 완성하시오
# todo -3 : while문의 조건을 수정하여 6번의 기회가 소진되면 반복문이 종료될 수 있도록 작성하시오.
# todo -4 : lives의 변수와 stages 리스트의 관계를 파악하여 guess를 입력할 떄마다 올바른 stages의 element가 출력될 수 있도록 작성하시오.

lives = 6

word_list = ['apple','banana','camel']
chosen_word = random.choice(word_list)
display = []
print(chosen_word)
for _ in range(len(chosen_word)):
    display.append('_')
end_of_game = False
while not end_of_game:
    print(stages[lives])
    guess = input('알파벳을 입력하시오 >>> ').lower()
    for i in range(len(chosen_word)):
        if chosen_word[i] == guess:
            display[i] = guess
        

    # 틀렸을 때 lives를 1개씩 감하고 0이 되었을 때 gameover 시키는 부분
    if guess not in chosen_word:
        lives -= 1
        print(f'당신의 기회는 {lives}번 남았습니다!')
        print(' '.join(display))
        if lives == 0:
            print('모든 기회를 잃었습니다.')
            print(stages[lives])
            end_of_game = True
            print(f'정답은 {chosen_word} 입니다.')
    if '_' not in display:
        print('정답입니다 !!')
        end_of_game = True    # 이 시점에서 end_of_game이 True가 되었으므로 반복문이 실행되지 않음 -> 114번 코드라인이 실행된다는 것을 의미합니다.
        # break                   # 바로 반복문 정지 -> 114번 코드라인이 실행 x
        print(f'정답은 {chosen_word} 입니다.')

    # 현재 상황이 콘솔창에 출력돼서 user에게 안내가 가면 좋겠네요
    print(' '.join(display))
```
이상의 코드에서 
```python
end_of_game = False
while not end_of_game:
    print(stages[lives])
    guess = input('알파벳을 입력하시오 >>> ').lower()
    for i in range(len(chosen_word)):
        if chosen_word[i] == guess:
            display[i] = guess
        else :
            print('오답입니다!')
            lives -= 1
            if lives == 0:
                print('모든 기회를 잃었습니다.')
                print(stages[lives])
                end_of_game = True
```
라고 작성하면 안됩니다. 반복문 내부에서 guess가 일치하는지 여부를 따지는 중 입니다. 예를 들어 chosen_word가 apple이고, guess가 a라고 가정했을 때, 첫 번째 반복문에서는 display의 0번지가 a로 바뀝니다. 그런데 반복문 내부에 위치해 있기 때문에 1,2,3,4번지에 대해서도 a가 display의 인덱스와 일치하는 element인지를 확인하게 됩니다. 그 결과 pple가 a와 다르기 때문에 lives -=1 이 4 번 적용되어서 맞는 답을 입력했음에도 불구하고 행맨이 완성되는 것을 확인할 수 있게 됩니다.

우리는 이상을 이유로 for 반복문의 바깥에서 guess가 chosen_word에 속하지 않는지를 확인하는 조건문을 '별개로' 작성해야만 합니다.

#### 최종 완성본
```python
import random

stages = ['''
  +---+
  |   |
  O   |
 /|\  |
 / \  |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|\  |
 /    |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|\  |
      |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========''',
'''
  +---+
  |   |
  O   |
  |   |
      |
      |
=========
''', '''
  +---+
  |   |
  O   |
      |
      |
      |
=========
''', '''
  +---+
  |   |
      |
      |
      |
      |
=========
''']

logo = '''
                                                                                               
 ,dPYb,                                                                                        
 IP'`Yb                                                                                        
 I8  8I                                                                                        
 I8  8'                                                                                        
 I8 dPgg,     ,gggg,gg   ,ggg,,ggg,     ,gggg,gg   ,ggg,,ggg,,ggg,     ,gggg,gg   ,ggg,,ggg,   
 I8dP" "8I   dP"  "Y8I  ,8" "8P" "8,   dP"  "Y8I  ,8" "8P" "8P" "8,   dP"  "Y8I  ,8" "8P" "8,  
 I8P    I8  i8'    ,8I  I8   8I   8I  i8'    ,8I  I8   8I   8I   8I  i8'    ,8I  I8   8I   8I  
,d8     I8,,d8,   ,d8b,,dP   8I   Yb,,d8,   ,d8I ,dP   8I   8I   Yb,,d8,   ,d8b,,dP   8I   Yb, 
88P     `Y8P"Y8888P"`Y88P'   8I   `Y8P"Y8888P"8888P'   8I   8I   `Y8P"Y8888P"`Y88P'   8I   `Y8 
                                            ,d8I'                                              
                                          ,dP'8I                                               
                                         ,8"  8I                                               
                                         I8   8I                                               
                                         `8, ,8I                                               
                                          `Y8P"                                                
'''

print(logo)
lives = 6
word_list = [
    "abolish", "contemporary", "absorb", "accommodate", "advise", "acquire", "adequate", "affect", "afford", "aggressive",
    "aid", "alert", "allege", "allowance", "amuse", "analyze", "ancient", "announce", "anxious", "apparent",
    "appeal", "appreciate", "approach", "appropriate", "approve", "argue", "arise", "artificial", "ascend", "assert",
    "assess", "associate", "assume", "attempt", "attend", "attitude", "authority", "avoid", "aware", "benefit",
    "bizarre", "blame", "boost", "boundary", "brave", "breach", "breathe", "broad", "capture", "career",
    "cautious", "celebrate", "challenge", "character", "circumstance", "civil", "claim", "coexist", "collapse", "commit",
    "communicate", "community", "compare", "compete", "complain", "complex", "complicate", "comply", "compose", "comprehend",
    "comprise", "compromise", "conceal", "concentrate", "concept", "concern", "conclude", "concrete", "condemn", "conduct",
    "confer", "confess", "confine", "confirm", "conflict", "conform", "confront", "consecutive", "consequence", "conserve",
    "considerable", "consistent", "constitute", "construct", "consult", "consume", "contact", "contain", "contend", "context",
    "contract", "contradict", "contribute", "controversy", "convention", "convert", "convince", "cooperate", "correspond", "courage",
    "critical", "crucial", "cultivate", "curious", "decline", "decrease", "dedicate", "define", "degrade", "delay",
    "deliberate", "demand", "demonstrate", "deny", "depart", "depend", "depict", "depress", "derive", "descend",
    "describe", "deserve", "designate", "desire", "desperate", "destroy", "determine", "develop", "devise", "devote",
    "diagnose", "differ", "difficult", "diligent", "diminish", "disappear", "disappoint", "discipline", "discover", "discourage",
    "discuss", "disrupt", "distinct", "distinguish", "distort", "diverse", "divide", "domestic", "dominate", "dramatic",
    "durable", "dynamic", "eager", "eccentric", "efficient", "elaborate", "elect", "eliminate", "embrace", "emerge",
    "emphasize", "enable", "encourage", "endorse", "engage", "enhance", "enormous", "entertain", "entire", "environment",
    "erode", "essential", "establish", "evaluate", "evident", "evolve", "exaggerate", "exceed", "excellent", "exception",
    "exhaust", "exhibit", "exist", "expand", "expect", "expensive", "experience", "explain", "explicit", "explore",
    "expose", "express", "extend", "extraordinary", "fabricate", "facilitate", "familiar", "fascinate", "favorable", "feasible",
    "feature", "federal", "feeble", "fierce", "finance", "flexible", "flourish", "fluctuate", "focus", "forbid",
    "forecast", "formulate", "foster", "fragile", "frequent", "fulfill", "fundamental", "furthermore", "generate", "generous"
]
chosen_word = random.choice(word_list)
display = []

for _ in range(len(chosen_word)):
    display.append('_')
end_of_game = False

while not end_of_game:
    print(stages[lives])
    guess = input('알파벳을 입력하시오 >>> ').lower()
    for i in range(len(chosen_word)):
        if chosen_word[i] == guess:
            display[i] = guess

    if guess not in chosen_word:
        lives -= 1
        print(f'당신의 기회는 {lives}번 남았습니다!')
        print(' '.join(display))
        if lives == 0:
            print('모든 기회를 잃었습니다.')
            print(stages[lives])
            end_of_game = True
            print(f'정답은 {chosen_word} 입니다.')
            break

    if '_' not in display:
        print('정답입니다 !!')
        end_of_game = True
        print(f'정답은 {chosen_word} 입니다.')


    print(' '.join(display))
```
하지만 이렇게 한다면 너무 길어지기 때문에 hangman_arts, hangman_word_list라는 file을 만들어 logo와 stages, word_list들을 따로 옮긴 뒤 file을 import 할 수 있다.
외부의 hangman_word_list에 있는 word_list를 참조해서 저희는 chosen_word를 만들 수 있습니다.
모듈명.변수명 으로 파일의 데이터를 가져올 수 있습니다.
```python
import random
import hangman_arts             # 이게 파일명이라는 사실에 주목해야겠네요
import hangman_word_list
# 즉 logo / stages와 같은 변수는 아닙니다.

print(hangman_arts.logo)
chosen_word = random.choice(hangman_word_list.word_list)
print(chosen_word)

display = []
lives = 6

for _ in range(len(chosen_word)):
    display.append('_')
end_of_game = False

while not end_of_game:
    print(hangman_arts.stages[lives])
    guess = input('알파벳을 입력하시오 >>> ').lower()
    for i in range(len(chosen_word)):
        if chosen_word[i] == guess:
            display[i] = guess

    if guess not in chosen_word:
        lives -= 1
        print(f'당신의 기회는 {lives}번 남았습니다!')
        print(' '.join(display))
        if lives == 0:
            print('모든 기회를 잃었습니다.')
            print(hangman_arts.stages[lives])
            end_of_game = True
            print(f'정답은 {chosen_word} 입니다.')
            break

    if '_' not in display:
        print('정답입니다 !!')
        end_of_game = True
        print(f'정답은 {chosen_word} 입니다.')


    print(' '.join(display))
```
`import` 뿐만 아니라 `from import`도 가능한데
```python
import random
from hangman_arts import * # hangman_arts 파일의 전체 데이터를 가지고 온다는 의미
from hangman_word_list import *
```
이상의 형식으로 사용하면 됩니다.
더 나아가
```python
import hangman08

hangman08.play_hangman()
```
및 
```python
from hangman08 import * # play_hangman도 가능

play_hangman()
```
이렇게도 사용이 가능합니다.

## colection
python 대표 collection 종류
1. list 리스트 : 추가 / 수정 / 삭제가 언제나 가능 / 순서 있음
2. tuple 튜플 : 추가 / 수정 / 삭제가 불가능 / 순서 있음
3. set 세트 : 중복된 값의 저장이 불가능 / 순서 없음
4. dict 딕셔너리 : 키 + 값으로 관리

사용 예
```python
list_example = [30, 40, '김이',[100,'김삼']]
tuple_example = (10, 20, 30, '김사')
set_example = {100, 200, 300, 400, '김오'}
dictionary_example = {'이름' : '김일','나이':20, '학교':'코리아아이티'}

print(list_example)
print(tuple_example)
print(set_example)
print(dictionary_example)
```




